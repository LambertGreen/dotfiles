#+TITLE: Dotfiles
#+AUTHOR: Lambert Green
#+DESCRIPTION: Cross-platform system configuration management and package management system
#+STARTUP: overview


* Introduction

This is a cross-platform dotfiles and unified package management system - think of it as a better, more flexible =Topgrade=. It provides a single interface to manage packages across multiple package managers, while also handling dotfiles deployment and system configuration.

** Key Features

- **Unified Package Management** - Python-based orchestration layer manages all your package managers:
  - System: brew/cask, pacman/AUR, apt, mas, choco, winget, scoop
  - Development: npm, pip, pipx, gem, cargo
  - Applications: zinit (zsh), elpaca (emacs), lazy.nvim (neovim)
- **Cross-Platform** - Consistent experience across macOS, Linux (Arch/Ubuntu), and Windows
- **Work-Friendly** - Separate work/personal contexts to handle corporate restrictions
- **Modal Interface** - Clean main interface with specialized contexts for advanced operations
- **Comprehensive Testing** - Docker validates multi-package-manager scenarios

** Key Technologies

- **Python** - Unified package management orchestration layer
- **GNU Stow** - Symlink management for dotfiles deployment
- **Just** - Command runner with modular contexts for clean interface
- **Docker** - Automated testing including multi-package-manager validation
- **Machine Classes** - Package definitions using native package manager formats (Brewfile, packages.txt, requirements.txt)

* Quick Start

** Quick Reference (for returning users)

#+begin_src sh
# Initial setup
just configure                   # Configure machine class
just bootstrap                   # Install essential tools (Python, Just, Stow)
just stow                        # Deploy dotfiles
just install                     # Install all packages

# Daily operations
just update                      # Update registries & check for updates
just upgrade                     # Upgrade packages (interactive PM selection)
just check-health                # Verify system health

# Package manager control
just register-package-managers   # Enable/disable package managers
just list-package-managers       # Show available package managers
just package-summary             # Show package counts

# Advanced contexts (modal navigation)
just package-managers            # Enter PM context for granular control
just debugging                   # Enter debug context for troubleshooting
just testing                     # Enter test context for validation
#+end_src

** 1. Clone the Repository

Clone to =~/dev/my/dotfiles= (recommended path):

#+begin_src sh
mkdir -p ~/dev/my
git clone --recursive https://github.com/LambertGreen/dotfiles.git ~/dev/my/dotfiles
cd ~/dev/my/dotfiles
#+end_src

** 2. Configure Your System

Interactive configuration:

#+begin_src sh
./configure.sh
#+end_src

The script will auto-detect your platform and present available machine classes to choose from.

Available machine classes include:
- ~docker_essential_{arch|ubuntu}~: Minimal containers with basic CLI tools
- ~docker_developer_{arch|ubuntu}~: Development containers with multiple package managers
- ~laptop_personal_mac~: Personal MacBook with full development setup
- ~laptop_work_mac~: Work MacBook with enterprise-appropriate tools
- ~desktop_{gaming_win|home_ubuntu|work_win}~: Desktop systems with GUI applications
- ~wsl_work_ubuntu~: Windows Subsystem for Linux development environment

Each machine class defines specific package lists optimized for that use case.

Configuration is saved to =.dotfiles.env= for future use.

** 3. Bootstrap Your System

Install essential tools and package managers:

#+begin_src sh
just bootstrap
# Or directly: ./bootstrap.sh
#+end_src

This installs core tools:
- Python 3 (required for package management)
- Just (command runner)
- Stow (symlink management)
- Platform-specific package managers (brew, apt, pacman)

** 4. Deploy Configurations

Deploy dotfiles using the stow system:

#+begin_src sh
just stow
#+end_src

** 5. Install Packages

Install packages defined in your machine class:

#+begin_src sh
just install                  # Install everything (system, dev, and app packages)
#+end_src

The Python-based system automatically:
- Detects available package managers
- Reads machine class configurations
- Installs packages in proper order (system → dev → app)
- Handles admin/user separation for system packages

** 6. Verify Setup

Check that everything is configured correctly:

#+begin_src sh
just check-health
#+end_src

** 7. Configure Package Managers

After installation, enable/disable specific package managers:

#+begin_src sh
just register-package-managers   # Interactive PM selection
just list-package-managers       # Show detected PMs
#+end_src

* Package Management

After initial setup, the system provides environment-driven package management with user/admin separation:

** Package Installation

Install packages for your machine class:

#+begin_src sh
# Install everything (recommended)
just install                   # Installs all packages via Python orchestration
#+end_src

For granular control, enter the package-managers context:

#+begin_src sh
just package-managers          # Enter PM context
# Now in package-managers context:
just install-brew              # Install only Homebrew packages
just install-npm               # Install only npm packages
just install-emacs             # Install only Emacs packages
# Type 'exit' to return to main
#+end_src

The Python system manages:
- **System packages**: brew, apt, pacman, choco, winget, scoop
- **Development packages**: npm, pip, pipx, cargo, gem
- **Application packages**: emacs (elpaca), neovim (lazy.nvim), zsh (zinit)

** System Updates

Keep your system and packages up to date with a two-step process:

*** Check for Available Updates

First, update registries and see what updates are available:

#+begin_src sh
just update             # Update registries & check for updates
#+end_src

This operation:
- Updates package manager registries (fetches latest package info)
- Prompts you to select which package managers to check
- Shows which packages have updates available
- Does NOT install anything

*** Upgrade Packages

After reviewing available updates, upgrade when ready:

#+begin_src sh
just upgrade            # Interactive: select which PMs to upgrade
#+end_src

This will:
- Upgrade packages to their latest versions
- Clean up old versions where appropriate
- Admin upgrades may prompt for your password

*** Advanced Package Management

For granular control over specific package managers:

#+begin_src sh
just package-managers      # Enter package-managers context
# Now you can:
just check-brew           # Check only Homebrew
just upgrade-npm          # Upgrade only npm packages
just install-emacs        # Install only Emacs packages
# Type 'exit' to return
#+end_src

* Platform-Specific Notes

** macOS
- Uses Homebrew as primary package manager (brew/cask)
- GUI apps available in GUI_APPS categories
- Emacs via homebrew tap (emacs-plus@31)
- Platform-specific configs: git_osx, shell_osx, gnupg_osx

** Linux (Arch/Ubuntu)
- Arch: pacman (core) + AUR via yay helper
- Ubuntu: apt (core) + Homebrew Linux (additional packages)
- Emacs via AUR (emacs-plus) on Arch, apt on Ubuntu
- Platform-specific configs: git_linux, shell_linux, gnupg_linux

** Windows
- Scoop as primary package manager
- MSYS2 for Unix-like environment and additional packages
- Limited GUI application support
- Platform-specific configs: git_win, shell_msys2, gnupg_win

* Modal Interface (Advanced)

The system uses a modal interface with specialized contexts for advanced operations:

** Main Context
The main =just= interface shows only essential commands:
- Setup: configure, bootstrap, stow
- Package Management: install, update, upgrade
- System: check-health
- Info: show-config, package-summary

** Specialized Contexts

Enter contexts for advanced operations:

#+begin_src sh
# Testing context - Docker and Python tests
just testing
just test              # Run Python tests
just test-all-ubuntu   # Run Docker tests
exit                   # Return to main

# Debugging context - Health, logs, troubleshooting
just debugging
just logs              # View recent logs
just cleanup-broken-links  # Fix symlink issues
exit                   # Return to main

# Package managers context - Granular PM control
just package-managers
just check-brew        # Check only Homebrew
just upgrade-npm       # Upgrade only npm
exit                   # Return to main
#+end_src

* Health Check & Debugging

** System Health Validation

The health check tool validates your dotfiles setup:

#+begin_src sh
just check-health
#+end_src

It reports:
- Total symlinks managed by stow
- Any broken symlinks that need attention
- Overall system health status

** Advanced Debugging

For detailed troubleshooting, enter the debug context:

#+begin_src sh
just debugging         # Enter debug context
just logs              # View recent logs
just logs-errors       # Show only errors
just cleanup-broken-links      # Preview broken links
just cleanup-broken-links-remove  # Remove broken links
exit                   # Return to main
#+end_src

* Common Tasks

** Update Package Lists

The configuration system manages packages via machine class directories in `machine-classes/`. Each machine class contains package manager-specific files using native formats. To add new packages:

1. Identify the appropriate machine class (e.g., `docker_developer_ubuntu`, `laptop_personal_mac`)
2. Navigate to the appropriate package manager directory
3. Edit the package manager's native format file

Examples:
#+begin_src sh
# For Homebrew (macOS/Linux) - User packages (no sudo)
echo 'brew "your-new-package"' >> machine-classes/laptop_work_mac/brew/packages.user

# For Homebrew (macOS/Linux) - Admin packages (requires sudo)
echo 'cask "your-gui-app"' >> machine-classes/laptop_work_mac/brew/packages.admin

# For apt packages (Ubuntu)
echo "your-new-package" >> machine-classes/docker_developer_ubuntu/apt/packages.txt

# For pacman (Arch)
echo "your-new-package" >> machine-classes/docker_developer_arch/pacman/packages.txt
#+end_src

** Restow Configurations

If you've modified configs, restow to update symlinks:

#+begin_src sh
just stow    # Uses your configured platform automatically
#+end_src

** Show Current Configuration

View your current configuration settings:

#+begin_src sh
just show-config
#+end_src

* Troubleshooting

** Permission Denied Errors
- Ensure you have sudo access for bootstrap phase
- Package installation may require admin privileges
- Use =just debugging= context for detailed logs

** Symlink Conflicts
- Use =just check-health= to identify issues
- Enter debug context: =just debugging=
- Use =just cleanup-broken-links= to preview issues
- Remove conflicting files or use force install
- Common conflicts: =.bashrc=, =.zshrc= from system defaults

** Package Manager Issues
- Use =just list-package-managers= to see detected PMs
- Use =just register-package-managers= to enable/disable specific PMs
- Enter PM context for granular control: =just package-managers=
- Check Python cache: ensure no =__pycache__= directories are tracked

** Work Machine Restrictions
- Configure only the components you need on work machines
- GUI applications may require admin access on some systems
- Advanced window managers and system tools are in advanced categories for optional installation
- Use machine class system to define work-appropriate package sets

* Testing

The dotfiles project includes comprehensive Docker-based testing to validate configurations across multiple platforms and machine classes.

For detailed testing documentation, baselines, and success criteria, see [[file:test/Testing.org][Testing Documentation]].

* Contributing

1. Make changes in appropriate config directory (`configs/common/`, `configs/osx_only/`, etc.)
2. Test using Docker test infrastructure: `cd test && just test-developer-arch`
3. Run health check to verify changes: `just check-health`
4. Update machine class package lists if adding new packages
5. Submit PR with description of changes

For more detailed information, see the comprehensive setup guide in [[file:README.old.org][README.old.org]].
